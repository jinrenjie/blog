---
title: DevOps 之 Laravel 基于分支的多环境部署
date: 2022-09-15T10:54:30+08:00
author: George
authorTwitter: GeorgeBornAgain
cover: covers/20220915-multiple-environments-workflow.jpg
tags: [DevOps, Laravel, Gitlab CI]
keywords: [DevOps, Laravel, Gitlab CI]
description: 在多个需求并行开发的过程中，如果需要同时测试多个分支，这是一个让人头疼的问题。
showFullContent: false
readingTime: false
draft: false
---
# 前言

在我们之前的 DevOps Workflow 中，只有一套测试环境，也就是说我们如果要测试功能需要将 feature/* 分支的代码合并到 develop 分支，然后 Gitlab CI 执行部署。

因为我们的主要语言是 PHP 框架是 Laravel，处于成本考虑，没有采用打包容器的方式进行项目的部署。而是采用 Deployer SSH 到远端服务器进行部署。

如果没有并行的需求开发，这样也没什么问题。但经常会出现一些优先级较高的需求，需要穿插在当前已经在开发的功能中。之前我们只能等 develop 分支上的代码发布了以后才能将 feature/* 的代码合并到 develop 分支上进行测试。

而我们想实现的是，在测试服务器上基于分支部署多个测试环境，然后通过请求头区分要访问的测试分支。

例如开发者 A 创建了  `feature/sso`, 那么当该分支被推送到 Gitlab 时，则执行部署流程，测试人员可以通过在请求头中附加 `X-Branch: feature/sso` 来访问指定分支的测试环境。

为了实现这一功能，我调研了诸多方案，将在下面罗列并分析优劣，以供参考！

# Gitlab CI 改造

将原来的仅监听 develop 分支的变化并执行 CI 流程，改为监听除 master 分支以外的所有流程。

```yaml
stages:
  - deploy
variables:
  VERBOSE: ""

deploy:preview:
  image: betterde/deployer:6.8.0
  only:
    refs:
      - branches # 只有分支变动才会触发 CI/CD
  except:
    refs:
      - master # 排除 master 分支的 CI/CD，因为我们发布到生成环境是基于 tags 的
  stage: deploy
  tags:
    - backend
  script:
    - mkdir -p ~/.ssh
    - echo "$SSH_PRIVATE_KEY" >> ~/.ssh/id_rsa
    - chmod 600 ~/.ssh/id_rsa
    - deployer deploy preview --branch "$CI_COMMIT_REF_NAME" --gitlab_domain "$GITLAB_DOMAIN" --gitlab_personal_token "$PERSONAL_TOKEN" $VERBOSE
  environment:
    name: preview
    url: $PREVIEW_URL
```
上面的配置中，核心在于 `only` 和 `except` 两个配置项，以及 `script` 的最后一条脚本。当除了 `master` 分支以外的分支触发了流程是，会将分支名传递给 deployer 进行部署，下面就分析一下 deploy.php 的配置，如何实现基于分支的多环境部署。

> 最后一条指令中用到了 --gitlab_domain 和 --gitlab_personal_token 是我们自定义的参数，因为在我们的项目中使用到了基于 Gitlab 的私有 Composer 扩展包，所以需要提供 Gitlab 身份认证信息，来拉取扩展包。

# Deployer 配置

```php
<?php

namespace Deployer;

use Symfony\Component\Console\Input\InputOption;

require 'recipe/laravel.php';

option('gitlab_domain', null, InputOption::VALUE_OPTIONAL, 'Defien Gitlab domain name');
option('gitlab_personal_token', null, InputOption::VALUE_OPTIONAL, 'Defien gitlab personal token');

// 设置默认的 stage
set('default_stage', 'preview');

// 保存最近五次部署，这样的话回滚最多也只能回滚到前 1 个版本
set('keep_releases', 1);

// 设置权限
set('writable_chmod_mode', '0777');

// 使用 chmod
set('writable_mode', 'chmod');

// 实践证明，这样能减少一些不必要的麻烦,如出现权限相关的问题，也可将此项设置为 true 后尝试
set('writable_use_sudo', false);

// Project repository
set('repository', 'git@gitlab.example.com:backend/crm.git');

// 用于私有扩展包访问授权信息
set('gitlab_domain', function () {
    if (input()->hasOption('gitlab_domain') && !empty(input()->getOption('gitlab_domain'))) {
        return input()->getOption('gitlab_domain');
    }
    return 'gitlab.example.com';
});

set('gitlab_personal_token', function () {
    if (input()->hasOption('gitlab_personal_token') && !empty(input()->getOption('gitlab_personal_token'))) {
        return input()->getOption('gitlab_personal_token');
    }
    return '';
});

// 为了缩短测试服的扩展包更新流程，我们采用单独的测试环境 composer 配置，从本地加载扩展包
set('composer_install', function () {
    $command = 'composer install --verbose --prefer-dist --no-progress --no-interaction --optimize-autoloader --no-suggest --no-dev';
    if (input()->getArgument('stage') == 'preview') {
        return sprintf('%s %s', 'COMPOSER=composer.dev.json', $command);
    }

    return $command;
});

set('bin/php', 'docker exec fpm bash -c "cd {{release_path}} && php"');

// 预览主机相关设置
host('SERVER_HOST')
    ->stage('preview')
    ->user('root')
    ->port(22)
    ->set('deploy_path', '/usr/wwwroot/laravel/{{branch}}')
    ->identityFile('~/.ssh/id_rsa')
    ->forwardAgent(true)
    ->multiplexing(true)
    ->set('http_user', 'www-data')
    ->addSshOption('UserKnownHostsFile', '/dev/null')
    ->addSshOption('StrictHostKeyChecking', 'no');

desc('Composer auth');
task('composer:auth', function () {
    run('docker exec fpm bash -c "cd {{release_path}} && composer config gitlab-token.{{gitlab_domain}} {{gitlab_personal_token}}"');
});

//option('tag', null, InputOption::VALUE_REQUIRED, 'Tag to deploy');
desc('Installing vendors');
task('deploy:vendors', function () {
    run('docker exec fpm bash -c "cd {{release_path}} && {{composer_install}}"');
});


desc('Opcache reset');
task('opcache:reset', function () {
    // Opcache reset
    run('docker restart fpm');
});

before('deploy:vendors', 'composer:auth');
after('deploy:failed', 'deploy:unlock');
after('cleanup', 'opcache:reset');
```
CI 在执行上述的 deploy 配置后，会在远端服务器上的 `/usr/wwwroot/laravel` 目录下基于分支创建同名的目录。例如分支为 feature/sso，那么最终的部署路径就是 `/usr/wwwroot/laravel/feature/sso`。

到这一步就完成了服务的部署，接下来还需要通过对 Nginx 的配置实现根据 X-Branch 头访问到对应的项目分支。

# Nginx 配置

```
server {
    listen 80;
    server_name laravel.example.com;

    access_log off;

    location / {
        return 301 https://$host$request_uri;
    }
}

server {
    listen 443 ssl http2;
    server_name laravel.example.com;

    # 设置默认分支，当用户没有在请求头中附加 X-Branch 请求头时，则默认访问 develop 分支
    set $branch develop;
    if ($http_x_branch) {
        # 如果检测到 X-Branch 请求头时，则将值作为分支
        set $branch $http_x_branch;
    }

    # 将项目分支作为 root 的路径参数
    set $base /usr/wwwroot/laravel/$branch/current;
    root $base/public;
    index index.php;

    access_log off;

    include components/ssl.conf;

    include components/security.conf;

    location / {
        try_files $uri $uri/ /index.php?$query_string;
    }

    # additional config
    include components/general.conf;

    # handle .php
    location ~ \.php$ {
        root $base/public;
        fastcgi_pass fpm:9000;
        include components/fastcgi.conf;
    }
}
```
通过上述配置，就可以实现 Nginx 将分支路由到指定分支的源码了，且新增分支无需修改 Nginx 的配置。这种好处是基于请求头进行路由，配置简单，不用改变当前环境。

还有一种是使用 Nginx Unit + PHP-CLI 来实现 PHP 服务，因为 Unit 本身支持通过 API 进行配置热更新，所以灵活性更高。

但是对于我们来说有两个问题：

* 将现有的 PHP-FPM 架构变更为 Unit
* 我们的项目是前后端混编，所以访问是比较依赖域名和端口的（代码中有较多硬编码，所以不敢轻易动）

![Debuging](/article/20220915-debug-joke.gif)

基于上述考虑，我们最终还是选择了 Nginx + PHP-FPM 的架构。

# 请求

为了实现分支的切换，需要再浏览器中安装 Header Editor 插件，用来修改请求头。

![Header Editor](/article/20220915-header-editor-x-branch.png)

经过这一番操作下来，就可以在测试服实现基于分支的多环境部署和测试了。

对于纯 API 项目而言，我们后面可能会考虑选择 Unit 这种方式或者直接使用 Go 开发，并使用 API Gateway 基于服务发现，自动路由多分支测试环境。

I hope this is helpful, Happy hacking...